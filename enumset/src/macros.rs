/// Everything in this module is internal API and may change at any time.
#[doc(hidden)]
pub mod __internal {
    /// A reexport of core to allow our macros to be generic to std vs core.
    pub use ::core as core_export;

    /// A reexport of serde so our users don't have to also have a serde dependency.
    #[cfg(feature = "serde")]
    pub use serde;

    /// Reexports of internal types
    pub use crate::{
        repr::{ArrayRepr, EnumSetTypeRepr},
        traits::{EnumSetConstHelper, EnumSetTypePrivate},
    };

    #[cfg(feature = "serde")]
    #[doc(hidden)]
    #[macro_export]
    macro_rules! __if_serde {
        ($($tt:tt)*) => {
            $($tt)*
        };
    }

    #[cfg(not(feature = "serde"))]
    #[doc(hidden)]
    #[macro_export]
    macro_rules! __if_serde {
        ($($tt:tt)*) => {};
    }

    /// Macro to wrap serde-related code generated by the derive, discarding it
    /// if serde support is not enabled.
    pub use __if_serde;

    /// Helper macro to retrieve the helper used in constant time operations.
    pub const fn op_helper<T: EnumSetConstHelper>(_: &T) -> T::ConstOpHelper {
        T::CONST_OP_HELPER
    }

    /// Helper macro to retrieve the helper used in constant time conversions.
    pub const fn init_helper<T: EnumSetConstHelper>(_: &T) -> T::ConstInitHelper {
        T::CONST_INIT_HELPER
    }

    pub use crate::record::EnumRecordUnderlying;

    pub const fn convert_mixed<T: crate::EnumSetTypeWithRepr>(
        a: crate::EnumSet<T>,
    ) -> crate::MixedEnumSet<T> {
        crate::MixedEnumSet { __priv_repr: a.__priv_repr }
    }

    pub const fn all_variants<K: crate::EnumSetTypeWithRepr, V>(
        _: &crate::EnumRecord<K, V>,
    ) -> K::AllVariants {
        K::ALL_VARIANTS
    }

    pub use crate::macros::record;
}

/// Functions for enum record macros.
pub mod record {
    use crate::{EnumRecord, EnumSetType};
    use core::mem::MaybeUninit;

    /// Helper function to construct the initial Option<T>
    pub const fn create_type_marker<T: EnumSetType, V>(_: fn(T) -> V) -> Option<(T, V)> {
        None
    }

    /// Helper function to construct an underlying array filled with `MaybeUninit<K>`
    pub const fn assoc_uninit_record<T: EnumSetType, V>(
        _: &Option<(T, V)>,
        uninit: T::RecordArray<MaybeUninit<V>>,
    ) -> T::RecordArray<MaybeUninit<V>> {
        uninit
    }

    /// Helper function to return all variants of an enumset type.
    pub const fn assoc_all_variants<T: EnumSetType, V>(_: &Option<(T, V)>) -> T::AllVariants {
        T::ALL_VARIANTS
    }

    /// Helper function to retrieve the helper used in constant time operations.
    pub const fn assoc_init_helper<T: EnumSetType, V>(_: &Option<(T, V)>) -> T::ConstInitHelper {
        T::CONST_INIT_HELPER
    }

    /// Associates the return type with the enum type.
    pub const fn assoc_result<T: EnumSetType, V>(
        _: &Option<(T, V)>,
        result: T::RecordArray<V>,
    ) -> EnumRecord<T, V> {
        EnumRecord { underlying: result }
    }
}

/// Creates an [`EnumSet`](crate::EnumSet) literal, which can be used in const contexts.
///
/// The syntax used is `enum_set!(Type::A | Type::B | Type::C)`. Each variant must be of the same
/// type, or an error will occur at compile-time.
///
/// This macro accepts trailing `|`s to allow easier use in other macros.
///
/// # Examples
///
/// ```rust
/// # use enumset::*;
/// # #[derive(EnumSetType, Debug)] enum Enum { A, B, C }
/// const CONST_SET: EnumSet<Enum> = enum_set!(Enum::A | Enum::B);
/// assert_eq!(CONST_SET, Enum::A | Enum::B);
/// ```
///
/// This macro is strongly typed. For example, the following will not compile:
///
/// ```compile_fail
/// # use enumset::*;
/// # #[derive(EnumSetType, Debug)] enum Enum { A, B, C }
/// # #[derive(EnumSetType, Debug)] enum Enum2 { A, B, C }
/// let type_error = enum_set!(Enum::A | Enum2::B);
/// ```
#[macro_export]
macro_rules! enum_set {
    ($(|)*) => {
        $crate::EnumSet::empty()
    };
    ($value:path $(|)*) => {
        {
            $crate::__internal::init_helper(&$value).const_only($value)
        }
    };
    ($value:path | $($rest:path)|* $(|)*) => {
        $crate::enum_set_union!($value, $($rest,)*)
    };
}

/// Creates a [`MixedEnumSet`](crate::MixedEnumSet) literal, which can be used in const contexts.
///
/// The syntax used is `mixed_enum_set!(Type::A | Type::B | Type::C)`. Each variant must be of the same
/// type, or an error will occur at compile-time.
///
/// This macro accepts trailing `|`s to allow easier use in other macros.
///
/// # Examples
///
/// ```rust
/// # use enumset::*;
/// # #[derive(EnumSetType, Debug)] #[enumset(repr = "u32")] enum Enum { A, B, C }
/// const CONST_SET: MixedEnumSet<Enum> = mixed_enum_set!(Enum::A | Enum::B);
/// assert_eq!(CONST_SET, MixedEnumSet::from(Enum::A | Enum::B));
/// ```
///
/// This macro is strongly typed. For example, the following will not compile:
///
/// ```compile_fail
/// # use enumset::*;
/// # #[derive(EnumSetType, Debug)] enum Enum { A, B, C }
/// # #[derive(EnumSetType, Debug)] enum Enum2 { A, B, C }
/// let type_error = enum_set!(Enum::A | Enum2::B);
/// ```
#[macro_export]
macro_rules! mixed_enum_set {
    ($($internal:tt)*) => {
        $crate::__internal::convert_mixed($crate::enum_set!($($internal)*))
    };
}

/// Computes the union of multiple enums or constants enumset at compile time.
///
/// The syntax used is `enum_set_union!(ENUM_A, ENUM_B, ENUM_C)`, computing the equivalent of
/// `ENUM_A | ENUM_B | ENUM_C` at compile time. Each variant must be of the same type, or an error
/// will occur at compile-time.
///
/// # Examples
///
/// ```rust
/// # use enumset::*;
/// # #[derive(EnumSetType, Debug)] enum Enum { A, B, C }
/// const CONST_SET: EnumSet<Enum> = enum_set_union!(Enum::A, Enum::B);
/// assert_eq!(CONST_SET, Enum::A | Enum::B);
/// ```
#[macro_export]
macro_rules! enum_set_union {
    ($value:path $(,)?) => {
        $crate::enum_set!($value)
    };
    ($value:path, $($rest:path),* $(,)?) => {
        {
            let op_helper = $crate::__internal::op_helper(&$value);
            let value = $crate::enum_set!($value);
            $(let value = {
                let new = $crate::enum_set!($rest);
                op_helper.const_union(value, new)
            };)*
            value
        }
    };
}

/// Computes the intersection of multiple enums or constants enumset at compile time.
///
/// The syntax used is `enum_set_intersection!(ENUM_A, ENUM_B, ENUM_C)`, computing the equivalent
/// of `ENUM_A & ENUM_B & ENUM_C` at compile time. Each variant must be of the same type, or an
/// error will occur at compile-time.
///
/// # Examples
///
/// ```rust
/// # use enumset::*;
/// # #[derive(EnumSetType, Debug)] enum Enum { A, B, C, D }
/// const SET_A: EnumSet<Enum> = enum_set!(Enum::A | Enum::B);
/// const SET_B: EnumSet<Enum> = enum_set!(Enum::B | Enum::C);
/// const CONST_SET: EnumSet<Enum> = enum_set_intersection!(SET_A, SET_B);
/// assert_eq!(CONST_SET, Enum::B);
/// ```
#[macro_export]
macro_rules! enum_set_intersection {
    ($value:path $(,)?) => {
        $crate::enum_set!($value)
    };
    ($value:path, $($rest:path),* $(,)?) => {
        {
            let op_helper = $crate::__internal::op_helper(&$value);
            let value = $crate::enum_set!($value);
            $(let value = {
                let new = $crate::enum_set!($rest);
                op_helper.const_intersection(value, new)
            };)*
            value
        }
    };
}

/// Computes the complement of an enums or constants enumset at compile time.
///
/// # Examples
///
/// ```rust
/// # use enumset::*;
/// #[derive(EnumSetType, Debug)]
/// enum Enum { A, B, C, D }
///
/// const SET: EnumSet<Enum> = enum_set!(Enum::B | Enum::C);
/// const CONST_SET: EnumSet<Enum> = enum_set_complement!(SET);
/// assert_eq!(CONST_SET, Enum::A | Enum::D);
/// ```
#[macro_export]
macro_rules! enum_set_complement {
    ($value:path $(,)?) => {{
        let op_helper = $crate::__internal::op_helper(&$value);
        let value = $crate::enum_set!($value);
        op_helper.const_complement(value)
    }};
}

/// Computes the difference of multiple enums or constants enumset at compile time.
///
/// The syntax used is `enum_set_difference!(ENUM_A, ENUM_B, ENUM_C)`, computing the equivalent
/// of `ENUM_A - ENUM_B - ENUM_C` at compile time. Each variant must be of the same type, or an
/// error will occur at compile-time.
///
/// # Examples
///
/// ```rust
/// # use enumset::*;
/// # #[derive(EnumSetType, Debug)] enum Enum { A, B, C, D }
/// const SET_A: EnumSet<Enum> = enum_set!(Enum::A | Enum::B | Enum::D);
/// const SET_B: EnumSet<Enum> = enum_set!(Enum::B | Enum::C);
/// const CONST_SET: EnumSet<Enum> = enum_set_symmetric_difference!(SET_A, SET_B);
/// assert_eq!(CONST_SET, Enum::A | Enum::C | Enum::D);
/// ```
#[macro_export]
macro_rules! enum_set_difference {
    ($value:path $(,)?) => {
        $crate::enum_set!($value)
    };
    ($value:path, $($rest:path),* $(,)?) => {
        {
            let op_helper = $crate::__internal::op_helper(&$value);
            let value = $crate::enum_set!($value);
            $(let value = {
                let new = $crate::enum_set!($rest);
                op_helper.const_intersection(value, op_helper.const_complement(new))
            };)*
            value
        }
    };
}

/// Computes the symmetric difference of multiple enums or constants enumset at compile time.
///
/// The syntax used is `enum_set_symmetric_difference!(ENUM_A, ENUM_B, ENUM_C)`, computing the
/// equivalent of `ENUM_A ^ ENUM_B ^ ENUM_C` at compile time. Each variant must be of the same
/// type, or an error will occur at compile-time.
///
/// # Examples
///
/// ```rust
/// # use enumset::*;
/// # #[derive(EnumSetType, Debug)] enum Enum { A, B, C, D }
/// const SET_A: EnumSet<Enum> = EnumSet::all();
/// const SET_B: EnumSet<Enum> = enum_set!(Enum::B | Enum::C);
/// const CONST_SET: EnumSet<Enum> = enum_set_difference!(SET_A, SET_B);
/// assert_eq!(CONST_SET, Enum::A | Enum::D);
/// ```
#[macro_export]
macro_rules! enum_set_symmetric_difference {
    ($value:path $(,)?) => {
        $crate::enum_set!($value)
    };
    ($value:path, $($rest:path),* $(,)?) => {
        {
            let op_helper = $crate::__internal::op_helper(&$value);
            let value = $crate::enum_set!($value);
            $(let value = {
                let new = $crate::enum_set!($rest);
                op_helper.const_symmetric_difference(value, new)
            };)*
            value
        }
    };
}

/// Creates an [`EnumRecord`](crate::EnumRecord) literal from a closure, which can be used in
/// const contexts.
///
/// The macro should be called with a single closure, or the arms of a match expression. If it is
/// a closure, it is called to generate the value of each variant of the record. If it is the arms
/// of a match expression, each enum variant is matched against them to generate the value of each
/// variant of the record.
///
/// # Performance
///
/// This method is designed for use in const contexts. The code is likely very suboptimal for use
/// in dynamic code. Use [`EnumRecord::from_fn`](crate::EnumRecord::from_fn) instead in non-const
/// contexts.
///
/// # Examples
///
/// ```rust
/// # use enumset::*;
/// # #[derive(EnumSetType, Debug)] enum Enum { A, B, C }
/// const CONST_SET: EnumRecord<Enum, u32> = enum_record! {
///     Enum::A => 10,
///     Enum::B => 20,
///     Enum::C => 30,
/// };
/// assert_eq!(CONST_SET[Enum::A], 10);
/// assert_eq!(CONST_SET[Enum::B], 20);
/// assert_eq!(CONST_SET[Enum::C], 30);
/// ```
#[macro_export]
macro_rules! enum_record {
    (|$v:ident$(: $ty:ty)?| $body:expr $(,)?) => {{
        let ty_assoc = $crate::__internal::record::create_type_marker(|$v $(: $ty)*| $body);
        let mut record = $crate::__internal::record::assoc_uninit_record(
            &ty_assoc,
            unsafe { $crate::__internal::core_export::mem::MaybeUninit::uninit().assume_init() },
        );

        let mut i = 0;
        let all_variants = $crate::__internal::record::assoc_all_variants(&ty_assoc);
        let init_helper = $crate::__internal::record::assoc_init_helper(&ty_assoc);
        while i < all_variants.len() {
            let variant = all_variants[i];
            let $v $(: $ty)* = variant;
            let result = $body;
            unsafe {
                let ptr = record[init_helper.const_to_u32(variant) as usize].as_mut_ptr();
                ptr.write(result);
            }
            i += 1;
        }

        let result = unsafe { core::mem::transmute(record) };
        $crate::__internal::record::assoc_result(&ty_assoc, result)
    }};
    ($($body:tt)*) => {
        $crate::enum_record!(|x| match x { $($body)* })
    };
}
